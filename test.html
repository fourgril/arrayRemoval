<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
   <script type="text/javascript">
     // /*方法一双for循环去重*/
     // var arr = [1,23,1,1,1,23,5,6,7,9,12,9];
     // for(var i =0;i<arr.length-1;i++){
     //   for(var j = i+1;j<arr.length;j++){
     //     if(arr[i] == arr[j]){
     //       arr.splice(j,1);
     //       console.log(arr[j]);
     //       j--;
     //     }
     //   }
     // }
     // console.log(arr) ;
     //方法2借助indexOf()方法判断此元素在该数组中首次出现的位置下标与循环的下标是否相等。
     // var arr =[1,23,1,1,1,3,23,5,6,7,7,8];
     // for(var i =0;i<arr.length;i++){
     //   if(arr.indexOf(arr[i]) != i){
     //     arr.splice(i,1)//删除数组元素后数组长度减1后面的元素前移
     //     i--;//数组下标回退
     //   }
     // }
     // console.log(arr);
     // //方法三 利用数组中的filter方法
     // var arr =['apple','strawberry','banana','pear','apple','orange','orange','strawberry'];
     // var r =arr.filter(function (elelment,index,self) {
     //   return self.indexOf(elelment) === index;
     // })
     // console.log(r);
     //方法四 借助新数组 通过indexOf方判断当前元素在数组中的索引如果与循环的下标相等则添加到新数组中
     // var arr = [1,23,1,1,1,3,23,5,6,7,9,9,8,5];
     // var ret =[];
     // for(var i =0;i < arr.length;i++){
     //   if(arr.indexOf(arr[i]) == i){
     //      ret.push(arr[i]);
     //   }
     // }
     // console.log(ret);
     //方法五 利用空对象来记录数组中已经存储过的元素
     // var arr =[1,23,1,1,1,3,23,5,6,7,9,9,8,5];
     // var o ={};
     // var new_arr =[];
     // for(var i=0;i<arr.length;i++){
     //   var k = arr[i];
     //   if(!o[k]){
     //      o[k] = true;
     //      new_arr.push(k);
     //   }
     // }
     // console.log(new_arr)
     //方法六 借助新数组 判断新数组中是否存在该元素如果不存在则将此元素添加到新数组中
     // var arr =[1,23,1,1,1,3,23,5,6,7,9,9,8,5];
     // var newArr =[];
     // for(var i = 0;i<arr.length;i++){
     //   if(newArr.indexOf(arr[i]) == -1){
     //     newArr.push(arr[i]);
     //   }
     // }
     // console.log(newArr);
     // //方法七 (原数组长度不变但被字符串顺序排序 )，借助新数组 判断新数组中是否存在该元素如果不存在则将此元素添加到新数组中。
     // var arr =[1,23,1,1,1,3,23,5,6,7,9,9,8,5];
     // var ret =[] ,end;
     // arr.sort();
     // end = arr[0];
     // ret.push(arr[0]);
     // for(var i =1;i <arr.length;i++){
     //   if(arr[i] != end){//当前元素如果和临时元素不等则将此元素添加到新数组中
     //     ret.push(arr[i]);
     //     end =arr[i];
     //
     //   }
     // }
     // console.log(ret);
     // //方法八(此方法没有借助新数组直接改变原数组，并且去重后的数组被排序)
     // var arr =[1,23,1,1,1,3,23,5,6,7,9,9,8,5];
     // var end;//临时变量用于对比重复元素
     // arr.sort();
     // end =arr[0];
     // for(var i =1;i<arr.length;i++){
     //   if(arr[i] == end){
     //     arr.splice(i,1);
     //     i--
     //   }else{
     //     end = arr[i];
     //   }
     // }
     // console.log(arr);
     // //方法九（双层循环改变原数组）
     // var arr =[1,23,1,1,1,3,23,5,6,7,9,9,8,5];
     // for(var i =0;i<arr.length;i++){
     //   for(var j =0;j<arr.length;j++){
     //     if(arr[i] == arr[j] && i != j){
     //       arr.splice(j,1);
     //     }
     //   }
     // }
     // console.log(arr);
     //方法十（借助新数组）
     var arr =[1,23,1,1,1,3,23,5,6,7,9,9,8,5];
     var newArr = [];
     for(var i =0;i<arr.length;i++){
       var repArr = [];//接收重复数据后面的下标
       //内层循环找出有重复数据的下标
       for(var j=i+1;j<arr.length;j++){
         if(arr[i] == arr[j]){
           repArr.push(j);//找出后面重复数据的下标
         }
       }
         if(repArr.length == 0){
           newArr.push(arr[i]);//若重复数组没有值说明其不是重复数据
         }
     }
     console.log(newArr);
   </script>
</head>
<body>
   <div class="parent">
     <div class="child">只dd用来测试数组去重</div>
   </div>
</body>
</html>
